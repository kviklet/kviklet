package dev.kviklet.kviklet.proxy

import dev.kviklet.kviklet.db.ExecutePayload
import dev.kviklet.kviklet.service.EventService
import dev.kviklet.kviklet.service.dto.AuthenticationDetails
import dev.kviklet.kviklet.service.dto.ExecutionRequest
import dev.kviklet.kviklet.service.dto.utcTimeNow
import org.postgresql.core.PGStream
import org.postgresql.core.QueryExecutorBase
import org.postgresql.core.v3.ConnectionFactoryImpl
import org.postgresql.util.HostSpec
import java.io.InputStream
import java.io.OutputStream
import java.net.ServerSocket
import java.net.Socket
import java.net.SocketTimeoutException
import java.nio.ByteBuffer
import java.nio.charset.Charset
import java.time.LocalDateTime
import java.util.*
import java.util.concurrent.Executors
import kotlin.random.Random
import kotlin.reflect.full.memberProperties
import kotlin.reflect.jvm.isAccessible

class Connection(
    val clientSocket: Socket,
    var targetSocket: Socket,
    private val eventService: EventService,
    private val executionRequest: ExecutionRequest,
    private val userId: String,
    private val username: String,
    private val password: String,

) {
    var clientInput: InputStream = clientSocket.getInputStream()
    var clientOutput: OutputStream = clientSocket.getOutputStream()
    var targetInput: InputStream = targetSocket.getInputStream()
    var targetOutput: OutputStream = targetSocket.getOutputStream()

    var targetHost: String = ""
    var targetPort: Int = 5432
    var params: Map<String, String> = emptyMap()

    private var md5Salt = byteArrayOf()

    private val boundStatements: MutableMap<String, Statement> = mutableMapOf()

    private var proxyUsername = "postgres"
    private var proxyPassword = "postgres"

    fun startHandling(
        targetHost: String,
        targetPort: Int,
        proxyUsername: String,
        proxyPassword: String,
        passThrough: Boolean = false,
        params: Map<String, String>,
    ) {
        this.proxyUsername = proxyUsername
        this.proxyPassword = proxyPassword
        this.targetHost = targetHost
        this.targetPort = targetPort
        this.clientInput = clientSocket.getInputStream()
        this.clientOutput = clientSocket.getOutputStream()
        this.targetInput = targetSocket.getInputStream()
        this.targetOutput = targetSocket.getOutputStream()
        this.params = params

        val clientBuffer = ByteArray(8192)
        val targetBuffer = ByteArray(8192)
        var lastClientMessage: MessageOrBytes? = null

        while (true) {
            if (clientInput.available() > 0) {
                val bytesRead = clientInput.read(clientBuffer)
                val data = clientBuffer.copyOf(bytesRead)
                if (passThrough) {
                    targetOutput.write(data, 0, data.size)
                    targetOutput.flush()
                } else {
                    for (clientMessage in parseDataToMessages(data)) {
                        val newData = clientMessage.message?.toByteArray() ?: clientMessage.bytes!!
                        if (clientMessage.response != null) {
                            clientOutput.write(clientMessage.response, 0, clientMessage.response.size)
                            clientOutput.flush()
                        } else {
                            targetOutput.write(newData, 0, newData.size)
                            targetOutput.flush()
                            lastClientMessage = clientMessage
                        }
                    }
                }
            }
            if (passThrough) {
                if (targetInput.available() > 0) {
                    val bytesRead = targetInput.read(targetBuffer)
                    val data = targetBuffer.copyOf(bytesRead)
                    clientOutput.write(data, 0, data.size)
                    clientOutput.flush()
                }
            } else {
                val singleByte = ByteArray(1)
                val bytesRead: Int = try {
                    targetInput.read(singleByte, 0, 1)
                } catch (e: SocketTimeoutException) {
                    0 // No data available
                }

                if (bytesRead > 0) {
                    // Data is available, prepend the read byte to the buffer
                    val availableBytes = targetInput.available()
                    var dataBuffer = ByteArray(availableBytes + 1)
                    System.arraycopy(singleByte, 0, dataBuffer, 0, 1)
                    if (availableBytes > 0) {
                        targetInput.read(dataBuffer, 1, availableBytes)
                    }

                    // Handle the data as before
                    var responseData = parseResponse(dataBuffer)
                    if (responseData.second == "SSL") {
                        dataBuffer = "N".toByteArray()
                    }
                    clientOutput.write(dataBuffer, 0, dataBuffer.size)
                    clientOutput.flush()
                }
            }

            if (lastClientMessage?.message?.isTermination() == true) {
                break
            }
        }
    }

    private fun printBytesAsHexAndUTF8(bytes: ByteArray, prefix: String) {
        println(
            "$prefix: ${bytes.joinToString(" ") { "%02x".format(it) }} - ${String(bytes, Charset.forName("UTF-8"))}",
        )
    }

    private fun parseDataToMessages(byteArray: ByteArray): List<MessageOrBytes> {
        // Check for SSL Request and startup message
        val buffer = ByteBuffer.wrap(byteArray)
        if (
            byteArray[0] == 0x00.toByte() &&
            byteArray[1] == 0x00.toByte() &&
            byteArray[2] == 0x00.toByte() &&
            byteArray[3] == 0x08.toByte() &&
            byteArray[4] == 0x04.toByte() &&
            byteArray[5] == 0xd2.toByte() &&
            byteArray[6] == 0x16.toByte() &&
            byteArray[7] == 0x2f.toByte()
        ) {
            // return N for no SSL
            val nByteArray = "N".toByteArray()
            return listOf(MessageOrBytes(null, byteArray, nByteArray))
        } else if (
            byteArray[0] == 0x00.toByte()
        ) {
            // return authentication okay as if we are in trust mode
            val responseBuffer = ByteBuffer.allocate(13)
            responseBuffer.put('R'.code.toByte())
            responseBuffer.putInt(12)
            responseBuffer.putInt(5)
            val salt = Random.nextInt(0, 10000)
            responseBuffer.putInt(salt)
            md5Salt = ByteBuffer.allocate(4).putInt(salt).array()
            val okByteArray = responseBuffer.array()
            val authMessage = MessageOrBytes(null, byteArray, okByteArray)
            return listOf(authMessage)
        }
        val messages = mutableListOf<MessageOrBytes>()
        while (buffer.remaining() > 0) {
            val header = buffer.get().toInt().toChar()
            val length = buffer.int
            val messageBytes = ByteArray(length - 4)
            buffer.get(messageBytes)
            val parsedMessage = ParsedMessage.fromBytes(header, length, messageBytes)

            if (parsedMessage is HashedPasswordMessage) {
                confirmPasswordMessage(parsedMessage)
                messages.add(
                    MessageOrBytes(
                        null,
                        parsedMessage.originalContent,
                        authenticationOk(),
                    ),
                )

                for (param in params) {
                    messages.add(
                        MessageOrBytes(
                            null,
                            parsedMessage.originalContent,
                            paramMessage(param.key, param.value),
                        ),
                    )
                }
                // param end message BackendKeyData
                messages.add(
                    MessageOrBytes(
                        null,
                        parsedMessage.originalContent,
                        backendKeyData(),
                    ),
                )
                messages.add(MessageOrBytes(null, byteArray, readyForQuery()))
                continue
            }
            if (parsedMessage is ParseMessage) {
                boundStatements[parsedMessage.statementName] = Statement(
                    parsedMessage.query,
                    parameterTypes = parsedMessage.parameterTypes,
                )
            }
            if (parsedMessage is BindMessage) {
                val statement = boundStatements[parsedMessage.statementName]!!
                boundStatements[parsedMessage.statementName] = Statement(
                    statement.query,
                    parsedMessage.parameterFormatCodes,
                    statement.parameterTypes,
                    parsedMessage.parameters,
                )
            }
            if (parsedMessage is ExecuteMessage) {
                val statement = boundStatements[parsedMessage.statementName]!!
                val executePayload = ExecutePayload(
                    query = statement.interpolateQuery(),
                )
                eventService.saveEvent(
                    executionRequest.id!!,
                    userId,
                    executePayload,
                )
            }

            messages.add(MessageOrBytes(parsedMessage, null))
        }
        return messages
    }

    private fun authenticationOk(): ByteArray {
        val responseBuffer = ByteBuffer.allocate(9)
        responseBuffer.put('R'.code.toByte())
        responseBuffer.putInt(8)
        responseBuffer.putInt(0)
        return responseBuffer.array()
    }

    private fun paramMessage(key: String, value: String): ByteArray {
        val responseBuffer = ByteBuffer.allocate(
            7 + key.toByteArray().size + value.toByteArray().size,
        )
        responseBuffer.put('S'.code.toByte())
        responseBuffer.putInt(6 + key.toByteArray().size + value.toByteArray().size)
        responseBuffer.put(key.toByteArray())
        responseBuffer.put(0.toByte())
        responseBuffer.put(value.toByteArray())
        responseBuffer.put(0.toByte())
        return responseBuffer.array()
    }

    private fun backendKeyData(): ByteArray {
        val responseBuffer = ByteBuffer.allocate(13)
        responseBuffer.put('K'.code.toByte())
        responseBuffer.putInt(12)
        responseBuffer.putInt(0)
        responseBuffer.putInt(0)
        return responseBuffer.array()
    }

    private fun readyForQuery(): ByteArray {
        val responseBuffer = ByteBuffer.allocate(6)
        responseBuffer.put('Z'.code.toByte())
        responseBuffer.putInt(5)
        responseBuffer.put('I'.code.toByte())
        return responseBuffer.array()
    }

    private fun confirmPasswordMessage(message: HashedPasswordMessage) {
        val password = message.message
        val expectedMessage = HashedPasswordMessage.passwordContent(this.proxyUsername, this.proxyPassword, md5Salt)
        if (!password.toByteArray().contentEquals(expectedMessage)) {
            throw Exception("Password does not match")
        }
    }

    private fun parseResponse(byteArray: ByteArray): Pair<ByteArray, String> = byteArray to "Not handled"
}

class Statement(
    val query: String,
    val parameterFormatCodes: List<Int> = mutableListOf(),
    val parameterTypes: List<Int> = mutableListOf(),
    val boundParams: List<ByteArray> = mutableListOf(),
) {
    override fun toString(): String =
        "Statement(query='$query', parameterFormatCodes=$parameterFormatCodes, boundParams=$boundParams)," +
            "interpolated query: ${interpolateQuery()}"

    fun interpolateQuery(): String {
        var interpolatedQuery = query
        for (i in 0 until boundParams.size) {
            val param = boundParams[i]
            val paramType = parameterTypes[i]
            val paramIndex = i + 1
            interpolatedQuery = interpolatedQuery.replace(
                "$$paramIndex",
                "'${PGTypeStringifier().convertToHumanReadableString(paramType, param)}'",
            )
        }
        return interpolatedQuery
    }
}

class PostgresProxy(
    private val targetHost: String,
    private val targetPort: Int,
    private val databaseName: String,
    private val authenticationDetails: AuthenticationDetails.UserPassword,
    private val eventService: EventService,
    private val executionRequest: ExecutionRequest,
    private val userId: String,
) {
    private var proxyUsername = "postgres"
    private var proxyPassword = "postgres"
    var isRunning = false;
    fun startServer(
        port: Int,
        proxyUsername: String,
        proxyPassword: String,
        startTime: LocalDateTime,
        maxTimeMinutes: Long,
    ) {

        this.proxyUsername = proxyUsername
        this.proxyPassword = proxyPassword

        val maxConnections = 15
        var currentConnections = 0
        val threadPool = Executors.newCachedThreadPool()
        this.isRunning = true
        ServerSocket(port).use { serverSocket ->
            while (true) {
                if (maxTimeMinutes != 0L) {
                    if (utcTimeNow().isAfter(startTime.plusMinutes(maxTimeMinutes))) {
                        // kill all running threads and close sockets
                        threadPool.shutdownNow()
                        serverSocket.close()
                        break
                    }
                }
                if (currentConnections >= maxConnections) {
                    Thread.sleep(1000)
                    continue
                }
                lateinit var clientSocket: Socket
                try {
                    clientSocket = serverSocket.accept()
                }catch(e: Exception) {
                    e.printStackTrace()
                }

                currentConnections++

                threadPool.submit {
                    try {
                        handleClient(clientSocket)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    } finally {
                        if (!clientSocket.isClosed) {
                            clientSocket.close()
                        }
                        currentConnections--
                    }
                }
            }
        }
    }
    private fun startTcpSocket(port: Int, maxTimeMinutes: Long, startTime: LocalDateTime) {
        val maxConnections = 15
        var currentConnections = 0
        val threadPool = Executors.newCachedThreadPool()
        var serverSocket = ServerSocket(port)
        while (true) {
            if (maxTimeMinutes != 0L) {
                if (utcTimeNow().isAfter(startTime.plusMinutes(maxTimeMinutes))) {
                    // kill all running threads and close sockets
                    threadPool.shutdownNow()
                    serverSocket.close()
                    break
                }
            }
            if (currentConnections >= maxConnections) {
                Thread.sleep(1000)
                continue
            }
            lateinit var clientSocket: Socket
            try {
                clientSocket = serverSocket.accept()
            }catch(e: Exception) {
                e.printStackTrace()
            }

            currentConnections++

            threadPool.submit {
                try {
                    handleClient(clientSocket)
                } catch (e: Exception) {
                    e.printStackTrace()
                } finally {
                    if (!clientSocket.isClosed) {
                        clientSocket.close()
                    }
                    currentConnections--
                }
            }
        }

    }
    private fun handleClient(clientSocket: Socket) {
        // {application_name=PostgreSQL JDBC Driver, client_encoding=UTF8, DateStyle=ISO, MDY, integer_datetimes=on, IntervalStyle=postgres, is_superuser=on, server_encoding=UTF8, server_version=9.6.24, session_authorization=postgres, standard_conforming_strings=on, TimeZone=Europe/Berlin}
        val passThroughMode = false
        clientSocket.use { socket ->

            val targetSocket: Socket
            val params: Map<String, String>

            if (!passThroughMode) {
                val hostSpec = HostSpec(targetHost, targetPort)
                val factory = ConnectionFactoryImpl()
                val props = Properties()
                props.setProperty("user", authenticationDetails.username)
                props.setProperty("password", authenticationDetails.password)
                val database = if (databaseName != "") databaseName else authenticationDetails.username
                props.setProperty("PGDBNAME", database)
                val queryExecutor = factory.openConnectionImpl(arrayOf(hostSpec), props) as QueryExecutorBase

                val queryExecutorClass = QueryExecutorBase::class

                // Find the property by name
                val pgStreamProperty = queryExecutorClass.memberProperties.firstOrNull { it.name == "pgStream" }
                    ?: throw NoSuchElementException("Property 'pgStream' is not found")

                // Make the property accessible
                pgStreamProperty.isAccessible = true

                // Get the property value
                val pgStream = pgStreamProperty.get(queryExecutor) as PGStream
                params = queryExecutor.getParameterStatuses()
                targetSocket = pgStream.socket
            } else {
                targetSocket = Socket(targetHost, targetPort)
                params = mapOf()
            }

            targetSocket.use { forwardSocket ->

                forwardSocket.soTimeout = 10

                Connection(
                    socket,
                    forwardSocket,
                    eventService,
                    executionRequest,
                    userId,
                    authenticationDetails.username,
                    authenticationDetails.password,
                ).startHandling(
                    targetHost,
                    targetPort,
                    proxyUsername,
                    proxyPassword,
                    passThroughMode,
                    params,
                )
            }
        }
    }
}

fun ByteArray.toHexString() = joinToString("") { "%02x".format(it) }
